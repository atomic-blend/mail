name: Build and Test

on:
  push:
    branches:
      - dev

env:
  OS: "debian12"
  COCOGITTO_VERSION: "6.3.0" # Specify the version of Cocogitto to use
  FLUTTER_VERSION: "3.35.4"

jobs:
  test-coverage:
    runs-on: [self-hosted, Linux]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: true

      - name: Check for Local Path Dependencies
        run: |
          echo "Checking pubspec.yaml for local path dependencies..."
          if grep -A1 -B1 "^[[:space:]]*[a-zA-Z0-9_-]*:" pubspec.yaml | grep -q "^[[:space:]]*path:"; then
            echo "❌ ERROR: Local path dependencies found in pubspec.yaml!"
            echo "The following lines contain 'path:' references:"
            grep -n "^[[:space:]]*path:" pubspec.yaml
            echo ""
            echo "Please remove all local path dependencies before committing."
            exit 1
          else
            echo "✅ No local path dependencies found in pubspec.yaml"
          fi

      - name: Install Dependencies
        run: flutter pub get

      - name: Lint
        run: dart analyze --fatal-infos

      # - name: Run Tests with Coverage
      #   run: |
      #     dart test --coverage=coverage
      #     dart pub global activate coverage
      #     dart pub global run coverage:format_coverage --lcov --in=coverage --out=coverage.lcov --report-on=lib

      # - name: Upload Coverage Reports
      #   uses: codecov/codecov-action@v3
      #   with:
      #     files: ./coverage.lcov
      #     fail_ci_if_error: true
      #     verbose: true

      # - name: Archive Coverage Report
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: coverage-report
      #     path: coverage.lcov
  release-rc:
    needs:
      - test-coverage
    runs-on: [self-hosted, Linux]
    outputs:
      tag: ${{ steps.push-and-prepare.outputs.docker_version }}
    steps:
      - name: Configure git
        run: |
          git config user.email "pro@brandonguigo.com"
          git config user.name "GitHub Actions"

      - name: Cache cocogitto
        id: cache-cocogitto
        uses: actions/cache@v3
        with:
          path: ~/.cargo/bin/cog
          key: cocogitto-${{ env.OS }}-v${{ env.COCOGITTO_VERSION }}

      - name: Install Rust
        if: steps.cache-cocogitto.outputs.cache-hit != 'true'
        uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true

      - name: Install Cocogitto
        if: steps.cache-cocogitto.outputs.cache-hit != 'true'
        run: |
          cargo install cocogitto --version ${{ env.COCOGITTO_VERSION }}
        env:
          RUSTFLAGS: --cfg procmacro2_semver_exempt

      - name: Run cog bump
        id: bump-versions
        run: |
          set -euo pipefail

          echo "Running bump script for single-repo..."

          # Run the bump script and capture output
          output=$(./bump_rc_single.sh 2>&1) || true
          echo "$output"

          # Extract NEW_TAG from script output (if present)
          NEW_TAG=$(echo "$output" | grep -E "^NEW_TAG:" | sed 's/^NEW_TAG://g' | tr -d '[:space:]') || true
          echo "DEBUG: Extracted NEW_TAG: '$NEW_TAG'"

          if [ -n "$NEW_TAG" ]; then
            TAGS_TO_PUSH="$NEW_TAG"
            SUCCESSFUL_DIRS='.'
          else
            TAGS_TO_PUSH=""
            SUCCESSFUL_DIRS=""
          fi

          echo "DEBUG: Final TAGS_TO_PUSH = '$TAGS_TO_PUSH'"
          echo "tags_to_push=$TAGS_TO_PUSH" >> $GITHUB_OUTPUT
          echo "successful_dirs=$SUCCESSFUL_DIRS" >> $GITHUB_OUTPUT

      - name: Push tags and prepare docker tag
        id: push-and-prepare
        run: |
          set -euo pipefail

          TAGS_TO_PUSH="${{ steps.bump-versions.outputs.tags_to_push }}"

          if [ -z "$TAGS_TO_PUSH" ]; then
            echo "No tags to push"
            echo "docker_tag=" >> $GITHUB_OUTPUT
            echo "docker_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Pushing tags: $TAGS_TO_PUSH"
          FIRST_TAG=""
          for tag in $TAGS_TO_PUSH; do
            echo "Pushing tag: $tag"
            git push https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git tag "$tag"
            if [ -z "$FIRST_TAG" ]; then
              FIRST_TAG="$tag"
            fi
          done

          # Use the first pushed tag to determine docker tag/version
          docker_tag="$FIRST_TAG"
          # Extract version: remove any dir prefix and leading 'v'
          if echo "$docker_tag" | grep -q '/v'; then
            docker_version=$(echo "$docker_tag" | sed 's:.*/v::')
          else
            docker_version=$(echo "$docker_tag" | sed 's/^v//')
          fi

          echo "DEBUG: docker_tag=$docker_tag docker_version=$docker_version"
          echo "docker_tag=$docker_tag" >> $GITHUB_OUTPUT
          echo "docker_version=$docker_version" >> $GITHUB_OUTPUT
      - name: Upload Changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md

      - name: Upload Pubspec
        uses: actions/upload-artifact@v4
        with:
          name: pubspec
          path: pubspec.yaml
  build-app-for-web:
    needs: release-rc
    runs-on: [self-hosted, Linux, docker-builder]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Download Pubspec
        uses: actions/download-artifact@v4
        with:
          name: pubspec
          path: ./
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: true
      - name: Write Firebase Options
        run: |
          cat > lib/firebase_options_prod.dart << 'EOF'
          ${{ secrets.FIREBASE_OPTIONS_PROD }}
          EOF

          cat > lib/firebase_options_dev.dart << 'EOF'
          ${{ secrets.FIREBASE_OPTIONS_DEV }}
          EOF

          cat > assets/configs/prod.json << 'EOF'
          ${{ secrets.APP_CONFIG_PROD }}
          EOF

          cat > assets/configs/dev.json << 'EOF'
          ${{ secrets.APP_CONFIG_DEV }}
          EOF
      - name: Build Web App
        run: |
          flutter clean
          flutter pub get
          flutter pub run build_runner build --delete-conflicting-outputs
          flutter build web --release -t lib/main_prod.dart --dart-define APP_ENV=prod --wasm
      - name: Upload Web App
        uses: actions/upload-artifact@v4
        with:
          name: web-app
          path: ./build/web
  build-and-push-docker:
    needs:
      - release-rc
      - build-app-for-web
    runs-on: [self-hosted, Linux, docker-builder]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Download Pubspec
        uses: actions/download-artifact@v4
        with:
          name: pubspec
          path: ./

      - name: Download Web App Artifact
        uses: actions/download-artifact@v4
        with:
          name: web-app
          path: ./build/web

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile-prod
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/atomic-blend/mail-app:${{ needs.release-rc.outputs.tag }}
  create-github-release:
    needs:
      - release-rc
      - build-app-for-web
      - build-and-push-docker
    runs-on: [self-hosted, Linux]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog
          path: ./

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "stable"
      - name: Install ghr
        run: |
          go install github.com/tcnksm/ghr@latest

      - name: Create GitHub Release
        run: |
          echo "Creating GitHub release"
          TAG="${{ needs.release-rc.outputs.tag }}"
          echo "Release tag: $TAG"

          # Extract changelog for the current version - improved approach
          # Handle tags with or without 'v' prefix
          CLEAN_TAG=$(echo "$TAG" | sed 's/^v//')
          echo "Clean tag for changelog matching: $CLEAN_TAG"

          CHANGELOG=""
          if [ -f "CHANGELOG.md" ]; then
            # First try exact match with the tag format in the file
            CHANGELOG=$(sed -n "/^## $TAG - /,/^## /p" CHANGELOG.md | sed '1d;$d')

            # If nothing found, try without the 'v' prefix
            if [ -z "$CHANGELOG" ]; then
              CHANGELOG=$(sed -n "/^## $CLEAN_TAG - /,/^## /p" CHANGELOG.md | sed '1d;$d')
            fi

            # If still nothing, look for formats like [x.y.z]
            if [ -z "$CHANGELOG" ]; then
              CHANGELOG=$(sed -n "/^## \[$CLEAN_TAG\] - /,/^## /p" CHANGELOG.md | sed '1d;$d')
            fi
          fi

          echo "CHANGELOG content:"
          echo "$CHANGELOG"

          echo "$CHANGELOG" >> release_notes.md

          echo "Release notes: $(cat release_notes.md)"

          # Use GitHub's built-in release creation
          gh release create $TAG \
            --title "v$TAG" \
            --notes "$(cat release_notes.md)" \
            --target ${{ github.sha }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
